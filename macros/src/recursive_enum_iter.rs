use std::collections::BTreeMap;

use proc_macro::TokenStream;
use syn::{parse::Parse, Ident, ItemEnum, Type};

/// Struct that represents the input to the `RecursiveEnumIter` derive macro.
pub struct RecursiveEnumIter {
	/// The name of the enum.
	name: Ident,
	/// A map from variant names to the types of the fields of the variant.
	variants: BTreeMap<Ident, Vec<Type>>,
}

impl Parse for RecursiveEnumIter {
	fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
		let variants = input.parse::<ItemEnum>()?;
		let name = variants.ident;
		let variants = variants
			.variants
			.into_iter()
			.map(|variant| {
				let fields = match variant.fields {
					syn::Fields::Unit => vec![],
					syn::Fields::Named(fields) => {
						fields.named.into_iter().map(|field| field.ty).collect()
					}
					syn::Fields::Unnamed(fields) => {
						fields.unnamed.into_iter().map(|field| field.ty).collect()
					}
				};
				(variant.ident, fields)
			})
			.collect();
		Ok(Self { variants, name })
	}
}

/// Derive macro that generates an `iter` method for an enum that returns an
/// iterator over all possible variants of the enum. This iterator is recursive,
/// meaning that it will also iterate over all possible variants of any enum
/// fields.
pub fn parse(input: TokenStream) -> TokenStream {
	let RecursiveEnumIter { variants, name } = syn::parse_macro_input!(input as RecursiveEnumIter);
	let iter = variants
		.into_iter()
		.enumerate()
		.flat_map(|(index, (variant, types))| {
			types
				.into_iter()
				.enumerate()
				.map(|(type_index, r#type)| {
					if index == 0 && type_index == 0 {
						quote::quote! {
							#r#type::iter().map(Self::#variant)
						}
					} else {
						quote::quote! {
							.chain(#r#type::iter().map(Self::#variant))
						}
					}
				})
				.collect::<Vec<_>>()
		})
		.collect::<Vec<_>>();

	quote::quote! {
		impl #name {
			/// Returns an iterator over all possible variants of this enum. This iterator is
			/// recursive, meaning that it will also iterate over all possible variants of any
			/// enum fields. This is autogenerated by the `RecursiveEnumIter` derive macro.
			fn iter() -> impl ::std::iter::Iterator<Item = Self> {
				#(#iter)*
			}
		}
	}
	.into()
}
